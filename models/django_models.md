Описание Моделей
---
---


Фреймворк Django №4
---
---

Создание Суперпользователя с правами админа.
---
Создать суперпользователя с правами допуска в административную часть,
можно при помощи специальной утилиты:

```
python3 manage.py createsuperuser

Username: admin
Email address: admin@example.com
Password: **********
Password (again): *********

Superuser created successfully.
```

Теперь мы имеем допуск в административную часть проекта, войдем в админку
по следующему адресу: http://127.0.0.1:8000/admin/

Войдя в админку сайта мы увидим две категории: Группы и Пользователи,
они определены при помощи `django.contrib.auth` дефолтного приложения в Dj
которое определено по дефолту еще в файле настроек.
И позволяют создавать/редактировать ... пользователей и категории к которым 
они могут принадлежать.

---
Статические файлы стилей для админ-панели
---

Для наших приложений мы используем стили и js код который определяем сами,
но для админки используются предопределенные стили css и js код, этот код 
по дефолту предопределен в самом `Django` 

В `Django` по пути `django/contrib/admin/` определены различные файлы для 
работы админки по дефолту, тут и миграции и шаблоны и выды и стили для
админки, принято копировать стили из админки с css, js и прочим кодом
из самого `Django` что установлен на компьютере в библиотеках, локально
на сам сайт.

То есть хранить предопределенные для админки стили, локально вместе со
стилями на самом сайте, для копирования всех этих файлов на проект, есть 
специальная команда:

```
python3 manage.py collectstatic

# Вывод
128 static files copied to '/var/www/Django-Lessons/coolsite/static'.
```

В файле настроек проекта `coolsite/settings.py` определены 2 константы,
они отвечают за то куда будут скопированы статические файлы, как для 
админки, так и для пользователей.

```python
STATIC_URL = '/static/'
STATIC_ROOT = 'static'
```

`STATIC_ROOT` - показывает какую директорию создать, и куда положить
скопированные данные.

---
Как получать данные из модели `<Model>.objects`
---
Для получения данных из модели в видах, и передачи тих данных в шаблон 
для отображения, импортируем этот класс модели в вид, и получим записи
через создание обьектов модели, и вызова специальных методов.

```python
from .models import Question

def index(request):
    all_questions = Question.objects.all()
    context = {'all_questions': all_questions}
    return render(request, 'polls/index.html', context=context)
```

Через специальный атрибут `objects` мы имеем доступ к методам, что
взаимодействуют с ORM, и возвращают результаты SQL запрососв.

У каждого полученного обьекта модели, по атрибутов самой модели, также 
присутствует еще одно поля, это поле `pk`.

Атрибут `pk` - содержит поле с первичным ключом, этот ключ может иметь 
нестандартное название, отличное от `id` и какое бы не было его название
оно хранится в поле `pk`

`<Model>.objects.all()` - получить все обьекты, все записи из таблицы
что есть в БД.

`<Model>.objects.get(pk=1)` - получить запись обьект записи из БД, где
первичное поле равняется `1`

`<Model>.objects.first()` - получить первую запись, с самым маленьким
значением по `id` или `None`

`<Model>.objects.last()` - возвращает последнюю запись из всех что есть 
по `id` или `None` 

`<Model>` - 

Фреймворк Django №3
---
---

База данных, модели, миграции и подключение моделей к админке.
---

ORM (Object-Relation Mapping) - обьектно-реляционное отображение, суть 
данной системы заключается в представлении таблиц БД, в качестве классов
программного кода, и инкапсуляции самого кода от конкретной СУБД, это 
своего рода прослойка между кодом и таблицами, для одинаковой работы с
любой СУБД.

В файле настроек `<project_name>/settings.py` определение с какой Бд будем 
работать, описывается в настройке `DATABASES`, с параметрами для работы,

Начальные настройки для подключения к БД :
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
В этом словаре с настройками можно увидеть ряд параметров, рассмотрим 
эти параметры подробнее:

1) `ENGINE` - указывает СУБД с которой будем работать, для разных СУБД 
параметры разные:

```
    'django.db.backends.sqlite3'
    'django.db.backends.postgresql'
    'django.db.backends.mysql'
```

2) `NAME` - это название БД, если используется `SQLite` то указывается
полный путь к файлу, для указания на корень проекта в `settings.py`
самим Django предопределена специальная константа `BASE_DIR` которая
указывает на корень проекта.

В зависимости от выбранной СУБД количество настроек будет разным, для 
`sqlite3` статочно таких:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
      
        # В корне проекта лежит файл с БД sqlite3 
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

Для использования PostgreSQL параметры будут другими:

```python
        DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': 'lessons-django',
            'USER': 'serg',
            'PASSWORD': '11',
            'HOST': '127.0.0.1',
            'PORT': '8000',
        }
    }
```

---
Создание моделей
---
Скажем мы хотим создать приложение `polls` которое будет создавать опрос
пользователей, нам потребуется создать 2 модели в приложении `polls`

1) Модель `Question` будет содержать 2 поля, Вопрос и Дату публикации. 

2) Модель `Choice` будет содержать 2 поля, Текст выбора и Подсчет голосов,
каждый `Choice` связан с `Question`.

В файле `polls/models.py` создадим наши модели, каждая модель будет 
задаваться как класс с именем в соответствии с таблицей в БД.

Тут все взаимодействие происходит через класс models, каждая модель 
наследуется от `django.db.models.Model` каждое свойство(поле) данного класса
реализуется как столбец таблицы и как класс наследуемый от `models`.

Каждое поле представлено своим классом:
   
1. `models.CharField` - реализует тип данных char
2. `models.DateTimeField` - дата/время
3. `models.ForeignKey` - внешний ключ
4. `models.IntegerField` - целое число

Обратим внимание, что мы не задаем первичный ключ в каждой из моделей,
он будет создан автоматически.

```python
# импорт модуля для создания моделей
from django.db import models

# модель для вопросов с 2 полями
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

# дель для выборов опросов
class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```


---
Применение миграций `migrate`
---

Когда мы создали миграцию и посмотрели на ее `SQL` код, теперь ее 
требуется исполнить, для этого можно воспользоваться все той же командой
`python3 manage.py migrate` она анализирует все приложения, ищет все файлы
в папках миграций всех приложений, и сверяет не появилось ли там новых 
миграций, информация о том какие миграции уже были применены, хранятся в
специальных таблицах в БД.

```
python3 manage.py migrate

Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Applying polls.0001_initial... OK
```

В выводе можно увидеть что для приложений: admin, auth, contenttypes, 
polls, sessions ведется поиск на новые миграции, в разделе 
`Running migrations` показаны какие миграции применены к БД, строка
`polls.0001_initial` говорит о том что для приложения `polls` применена
миграция `0001_initial`  файла `polls/migrations/0001_initial.py`

---

---

Константы `MEDIA_ROOT` `MEDIA_URl`
---

В модели мы можем определить поле типа `models.ImageField` для 
автоматической загрузки изображения, в папку по указанному пути, вот 
как это работает.

Если в поле модели мы указываем такой путь:

```python
    photo = models.ImageField(upload_to="Изображение")
```

То когда мы сделаем загрузку изображения на сайт, в корне сайта будет 
автоматически создана директория с названием `Изображение` и в нее 
будет помещен загруженный файл, и корневой каталог будет выглядеть так:

```
coolsite /
    coolsite  
    db.sqlite3  
    manage.py  
    polls  
    static  
    women  
    Изображение /
        Screenshot_from_2021-07-13_19-10-38.png
```

Это очень удобно, но есть одна проблема, если у м еня есть несколько 
моделей, и у каждой из моделей будут свое поле для загрузки изображений,
 мы будем получать новую директорию для каждой из моделей, к примеру так:

```python
class Model_1(models.Model):
    photo = models.ImageField(upload_to="photos/%Y/%m/%d/")
    
class Model_2(models.Model):
    photo = models.ImageField(upload_to="Изображение")
```

То мы получим следующую директорию:

```
coolsite /
    coolsite  
    db.sqlite3  
    manage.py  
    polls  
    static  
    women  
    photos / 
        2021 /
            08 /
                20 /
                    bass.png
    Изображение /
        Screenshot_from_2021-07-13_19-10-38.png
```

В файле `coolsite/settings.py` мы можем определить 2 константы: 

```python
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URl = '/media/'
```

Что нам это дает:

`os.path.join()` - соединяет строки вместе, при помощи специального
разделителя, который используется именно в текущей ОС, и возвращает
эту строку.

`BASE_DIR` - предопределенная константа, содержит в себе полный путь 
от корня всей ОС, до корня сайта.

`MEDIA_ROOT = os.path.join(BASE_DIR, 'media')` - эта константа будет
содержать полный путь от корня ОС, до папки `media` в корне сайта.

`MEDIA_ROOT` - когда эта константа определена, то при загрузки файлов
на сайт, будет создана директория `media` и в ней уже и будет созданы
директоии что были указаны в поле моделей.

И теперь наша структура будет выглядеть так:

```
coolsite / 
    coolsite  
    db.sqlite3  
    manage.py  
    polls  
    static  
    women
    media /
        photos / 
            2021 /
                08 /
                    20 /
                        bass.png
        Изображения / 
            2021 /
                08 /
                    20 /
                        Screenshot_from_2021-07-13_19-10-38.png
```

Таким образом структура загрузки изображений будет формироваться 
следующим образом `MEDIA_ROOT + models.ImageField()`

После того как мы создали модель с полем загрузки изображения, и 
подключили его модель в админку, а админке мы можем добавить запись
в БД, и загрузить картинку, однако открыть ее мы не сможем, для этого
потребуется сделать ряд изменений.

В файле `coolsite/settings.py` есть наши настройки, тут `MEDIA_ROOT` 
как мф уже выяснили, отвечает за директорию загрузки файлов.
```python
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URl = '/media/'
```

Другая же константа `MEDIA_URl` отвечает за то, по какому URL мы сможем
обращаться к этому файлу, устанавливаем ее в значение `/media/`

В файле `coolsite/urls.py` добавляем следующую запись с импортами нужных
модулей.

```python
"""coolsite URL Configuration"""
from django.contrib import admin
from django.urls import path, include
from women.views import *

# Импорт для работы с статическими файлами
from django.conf.urls.static import static
from coolsite import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path('women', include('women.urls')),
    path('polls', include('polls.urls'))
]

# Если мы в режиме DEBUG=True то добавляем специальный URL путь
# к статическим загруженным файлам в /media/
if settings.DEBUG:
    urlpatterns += static(
        settings.MEDIA_URL, document_root=settings.MEDIA_ROOT
    )
```

После этого все скаченные изображения будут доступны для просмотра, в
том числе и из админки.


---
Исключаем определенные поля модели из работы 
---
Нам требуется исключить из работы некоторые поля модели, мы можем
создать статический метод в котором определим кортеж с названиями полей
которые хотим исключить.

```python
class MyModel(models.Model):
    ...

    @staticmethod
    def get_exclude_filter_fields():
        """Названия полей, которые мы исключаем из фильтрации"""
        return ('id', 'description', 'create_date', 'update_date', )
```

Далее мы можем вызывать этот метод и проверять не находится ли поле
в списке запрещенных
```python
if field_name not in self.get_exclude_filter_fields():
    pass
```

---
Модели, атрибут `_meta`
---
У моделей есть защищенный атрибут `_meta`

`_meta.get_fields()` - возвращает список с обьектами полей модели

```python
self._meta.get_fields()

# Вывод
# 0 = {AutoField} creating.MenModel.id
# 1 = {MultiSelectField} creating.MenModel.men_sex
# 2 = {MultiSelectField} creating.MenModel.men_age
# 3 = {MultiSelectField} creating.MenModel.men_income
# ...
```

Используя это мы можем проитерироваться по этому списку и получить 
все имена полей модели.

Через атрибут `_meta` получаем список с названиями всех полей модели
в виде строк.
```python
model_field_names = [field.name for field in self._meta.get_fields()]

# Вывод
# {str} id
# {str} men_sex
# {str} men_age
# {str} men_income
```

`self.__dict__` - закрытый атрибут модели, представляет из себя словарь
с атрибутами обьекта.

Получаем словарь с названиями полей и выбранными значениями
```python
fields_and_values = {field.name: self.__dict__.get(field.name) for field in self._meta.get_fields()}

# Вывод
# {
#     'id': None,
#     'description': 'Введенное название',
#     'men_sex': [1],
#     'men_age': [1, 2],
#     'home_region': [18],
# }
```

Таким образом через атрибут `_meta` можно получить все поля и введенные
в эти поля значения пользователем.
