[//]: # ([Почитать №!]&#40;https://webdevblog.ru/sozdanie-api-interfejsa-graphql-s-pomoshhju-django/&#41;)

[//]: # ()
[//]: # ([Почитать №!]&#40;https://github.com/hasura/graphql-engine/blob/master/translations/README.russian.md&#41;)

[//]: # ()
[//]: # ([Почитать №2]&#40;https://temofeev.ru/info/articles/rabota-s-graphql-cherez-hasura-dlya-sistemnykh-analitikov-i-qa/&#41;)

[//]: # (Обучение hasura)

[//]: # ()
[//]: # (    https://medium.com/open-graphql/effortless-real-time-graphql-api-with-serverless-business-logic-running-in-any-cloud-8585e4ed6fa3)

[//]: # (    https://hasura.io/learn/)

[//]: # ()
[//]: # ()
[//]: # (Бизнес логика в hasura)

[//]: # ()
[//]: # (    https://hasura.io/learn/graphql/hasura/custom-business-logic/5-create-event-trigger/)

[//]: # (    https://dev.to/vladimirnovick/different-ways-of-adding-your-business-logic-to-hasura-16d)

---
Что такое `GraphQL`
---

>Если совсем просто то, представьте себе что на основе максимально
>упрощенного синтаксиса `SQL` был создан свой язык и назван `GraphQL`
> и на сервере есть своя точка API, всегда с методом `POST` вместо 
> множества точек с кучей методов как в `REST`. Когда фронту требуются
> данные он используя синтаксис `GraphQL` описывает те данные которые
> ему требуется получить, этот запрос летит на API и там расшифровывается
> в обычный язык SQL, после этот запрос исполняется, а данные в стандартном
> `JSON` формате летят обратно на клиент, совсем грубо, но механизм именно
> такой.

`GraphQL` - это язык запросов для API-интерфейсов, это синтаксис
описывающий как какие конкретно данные требуется получить из БД, 
при обращении к endpoint нашей API системы.

Стандартный подход `REST` предусматривает конкретные endpoint
для получения набора данных, при этом набор получаемых данных строго
фиксируемый, и если нам требуется другой набор данных то нам требуется 
либо изменить логику этого endpoint либо создать новый endpoint, или
получать все данные с этого endpoint и отсекать излишие.

`GraphQL` - позволяет в произвольной форме описывать какие данные 
требуется получить,

Все типы запросов на получение данных в `GraphQL` отправляются
через `POST` в то время как в архитектуре `REST` запросы на 
получение данных происходят методом `GET` и передаются в `URL`
как `get` параметры. 

Является следующим этапом развития архитектуры `API` приложений

    `SOAP` -> `REST` -> `GraphQL`

За счет того что `GraphQL` имеет свои изолированные типы данных, 
он не зависит не от языка программирования ни от типа СУБД, сервер
`GraphQL` может быть развернут на разных языках программирвоания,
и данные можно получать из разных СУБД.

[//]: # (---)

[//]: # (Модуль `Graphene`)

[//]: # (---)

[//]: # (`Graphene` - модуль для работы с `GraphQL` имеет интеграцию с )

[//]: # (`Djnago` позволяет развернуть сервер для обработки запросов`GraphQL`)

---
`GraphQL` как это работает
---
Для работы данного механизма нам требуется создать типы данных и 
схемы.

По сути мы создаем Модели и функции обработчики для этих моделей, 
подобно тому как в `Django` мы описываем модель для конкретной таблицы,
так же и в `GraphQL` мы создаем тип данных для таблицы.

Схемы (функции обработчики) это действия, которые будут выполняться 
и производить некотрые операции с данными тех типов которые в эти
функции переданы.

`GraphQL` во всей этой схеме, описывает то какие типы данных,
какими функциями обрабатывать.

---
Типы данных `GraphQL` 
---

Рассмотрим типы данных :

`ID` - указывает что этот параметр уникальный для этого типа данных

`String` - строка

`Int` - число

`['Другой тип данных']` - в качестве атрибута используется другой 
тип данных, по сути это является отображением связи таблицами в БД

`!` - указывает что этот атрибут обезателен

```text
type Actor {  
  id: ID!
  name: String!
}

type Movie {  
  id: ID!
  title: String!
  actors: [Actor]
  year: Int!
}
```


---
`GraphQL` запросы 
---
`query` - получение данных.

Параметр `query` говорит о том что это запрос, `users` это сущьность к 
которой мы обращаемся, а `fname` и `age` это атрибуты сущьности которые
мы хотим получить:
```text
query {
    users {
        fname
        age
    }
}
```

В ответ получаем `JSON` с обьектом`data` которая будет представляь
из себя ответ из тех и только из тех данных что были запрошены.

```text
data : {
    users [
        {
            "fname": "Joe",
            "age": 23
        },
        {
            "fname": "Betty",
            "age": 29
        }
    ]
}
```

---
`GraphQL` добавление данных
---
`Mutation` - добавление данных, это аналог `POST`, `PUT` в системе
`REST`

Каждый подобный запрос будет связан с функцией обработчиком, параметры
`fname: "Sergio", age: 30` указывают данные для новой записи которую 
требуется создать, а параметр `id` данные что требуется вернуть из 
созданной записи. 

```text
mutation createUser{
    addUser(fname: "Sergio", age: 30) {
        id
    }
}
```

В результате получим
```text
data : {
    addUser : 7
}
```

---
`GraphQL` подписки на получение данных
---
`Subscription` - подписка на получение данных, дял соединения 
используется вебсокеты, таким образом все изменения происходящие 
в БД будут в реальном времени отправлены на клиент.

```text
subscription listenLikes {
    listenLikes {
        fname
        likes
    }
}
```

Означает получать пользователей атрибуты `fname` и `likes` которых
меняются в режиме реального времени.

К примеру когда количество лайков сменится с 776 на 777, то мы 
получим ответ в таком формате.
```text
data: {
    listenLikes: {
        "fname": "Sergio",
        "likes": 777
    }
}
```

