Автоматическая генерация моделей
---

В случае если мы не разрабатываем приложение с нуля, работаем с уже существующей БД,
нам потребуется работать с моделями этой БД, но при создании модели, чтобы иметь 
возможность работать с ней, нам потребуется сделать миграцию и применить ее, но как 
быть когда таблица уже существует ? 

Как можно поступить:
- Создать модель, создать миграцию на нее и применить ложную миграцию, в таком случае
`Django` пометит миграцию как примененную, но в реальности ничего не сделает, так мы 
получим возможность работать с моделью, и миграция будет применена

Что делать если таблица для которой мы хотим сделать модель, имеет множество связей и
полей, на такой случай у `Django` есть возможность генерировать модели автоматически на 
основе уже существующей таблицы в БД, для этого есть специальная утилита `inspectdb`

По скольку это утилита, ее результат мы записываем с помощью операторы перенаправления
потока, записываем результат в файл :

```
python manage.py inspectdb > models.py
```

При таком создании модели, `Django` автоматически устанавливает параметр `managed = False`
в классе `Meta`, помним что это означает не отслеживать изменения в таблице, это 
значит что `Django` не управляет жизненным циклом данной таблицы и не отслеживает 
какие-либо изменения в ее структуре которые могли бы произойти, просто меняем этот
параметр на `True` или удаляем его ибо `True` это дефолтное значение.

```python
   class Meta:
       managed = False
```
---

Далее с такой моделью можно работать как и с любой другой, генерировать миграцию и 
применять ее как фейковую, ибо таблица уже существует и нам всего лишь требуется 
что бы в таблице миграций появилась отметка о применении миграции.

Инспектор баз данных полезен когда мы интегрируем проект `Django` к уже существующей
БД, а не создаем проект с самого начала.

---
Работа с разными схемами в БД
---

Помним что в СУБД `Postgres` есть деление на схемы, схема это просто пространство имен,
когда мы создаем таблицы в БД, она создается в пространстве имен схемы, и обращаться
мы можем к определенной таблице что находится в определенной схеме, таким образом мы
имеем возможность разбивать наши таблицы по участкам, скажем разделять таблицы по 
тематике.

По дефолту, каждая БД при создании определяет схему с названием `public` и все таблицы
будут создаваться именно там, если не указано иное.

При создании таблиц, название таблицы берется либо из названия модели нижнем регистре,
либо мы можем сами указать название под которым будет создана таблица, для этого
в классе `Meta` указываем атрибут `db_table` к примеру так :

```python
class Meta:
    db_table = 'my_model'
```

Возникает вопрос, как работать с другой схемой, если мы имеем несколько схем в БД,
как указать что наша модель должна работать с другой схемой, сделать это можно
следующим указанием:

```python
class Meta:
    db_table = 'schema_second\".\"my_model'
```

---

Представим себе ситуацию, у нас есть уже работающая БД, в которой определено несколько
рабочих схем, наша задача создать проект на `Django` и интегрировать эту уже 
существующую работающую БД в наше приложение.

Само приложение `Django` даже без создания наших моделей, уже имеет свои собственные
миграции, и перед началом работы с проектом эти миграции требуется накатить, по 
дефолту все миграции накатываются в главную схему `public`, но по скольку нам 
желательно отделить уже существующие таблицы от таблиц самого `Django`, и 
накатывать миграции туда, а не в ту схему, что уже имеет свои таблицы, сделать это
можно при помощи указания специальной опции при создании подключения к БД.

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'db',
        'USER': 'postgres',
        'PASSWORD': 123,
        'HOST': 'localhost',
        'PORT': 5432,
        'OPTIONS': {
            'options': '-c search_path=schema_second'
        }
    }
}
```
Теперь все миграции будут литься в ту схему которую мы указали в параметрах 
подключения.

Так же для взаимодействия с уже существующими таблицами, нам потребуется модель для 
этой таблицы, сделаем ее с помощью `inspectdb`, далее у сгенерированных моделей 
указываем с какой схемой им требуется работать, таким образом мы можем иметь 
множество моделей и каждая из них работает со своей таблицей в своей схеме, а все
миграции будут литься в ту схему, которую мы указали при подключении, то есть ту 
схему в которой и находятся наши таблицы для приложения `Django`

---
Взаимодействие с несколькими БД
---

У `Django` есть возможность работать с несколькими БД, одновременно. 




