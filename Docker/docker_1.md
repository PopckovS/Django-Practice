Что такое `Docker`
---

`Docker` - это система позволяющая создавать миниатюрные это `Virtual Box`
внутри которых можно запустить любое программное обеспечение.

---
Изображение `Docker Images`
---
`Docker Images` - это то что называется образом, образ это фундамент 
состоящий из начального набора конфигураций и зависимостей, к примеру
образом может являться `OC Linux`.

Образы служат для создания на их основе контейнеров, то есть образ 
это начальный набор правил для запуска миниатюрной виртуальной машины,
а контейнер это уже и есть запущенный на основе образа конкретный мини
`Virtual Box`

После сборки образа изменить его уже не получится, придется 
пересобирать заново.

Если на основе изображения был запущен контейнер, то удалить 
изображение без остановки контейнера можно только через силу.

---
Посмотреть изображения докера
---

Посмотреть все изображения можно такой командой:

    docker images


    REPOSITORY   TAG          IMAGE ID       CREATED        SIZE

    web_app      latest       31dd8a363408   15 hours ago   2.81GB
    <none>       <none>       e163ad2e6335   15 hours ago   2.81GB
    python       3.8-buster   85349ca642c4   2 weeks ago    884MB
    redis        alpine       f6f2296798e9   3 weeks ago    32.3MB

У каждого изображения есть уникальный `IMAGE ID` это его `hash`

Если у изображения во время сборки произошла ошибка, то его 
`REPOSITORY` будет в состоянии `<none>`

---
Удалить образ докера
---

Удалить изображение можно при помощи команды:

    docker rmi  <IMAGE ID>

Пример

    docker rmi  31dd8a363408

---
Создание своего образа, с тегом 
---

Создание образа из `Dockerfile`, мы можем создать некоторый проект,
мы можем сгенерировать образ из `Dockerfile`:

    docker build <DOCKERFILE_PATH> --tag <IMAGE_NAME>
    docker build . --tag my_project_tag

`my_project_tag` - мы можем дать этому образу тэг, по сути это имя 
данного образа, то есть образ будет иметь уникальный ID, и мы можем
дать ему еще и имя для простой ориентации между образами.

`.` - путь к директории, где лежит файл Dockerfile собрать из текущего
проекта.

---
Контейнеры `Docker Container`
---

Из уже собранных образов, можно создавать контейнеры, то есть мы 
берем образ докера и на его основе запускаем миниатюрный Virtual 
Box, в котором можно подкачивать зависимости, устанавливать 
библиотеки, изменять программный код, закачивать в него картинки, 
и прочее ...

После того как контейнер создан он может находиться в 2 состояниях,
он либо остановлен, то есть создан, но не запущен, либо находится в 
работе, то есть к нему можно обратиться через прокинутый порт, можно
войти в запущенный контейнер, провести ряд работ внутри него.

---
Посмотреть докер контейнеры
---

Посмотреть все существующие контейнеры можно

    docker ps -a

    CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS                      PORTS     NAMES

    9c3786ba438c   web_app        "celery -A config wo…"   15 hours ago   Exited (137) 14 hours ago             celery01
    07a95df7c93b   web_app        "python3 manage.py r…"   15 hours ago   Exited (137) 14 hours ago             web01
    248fec9e7a55   redis:alpine   "docker-entrypoint.s…"   15 hours ago   Exited (137) 14 hours ago             main_redis_1

В `STATUS` показано запущен контейнер или нет, в `PORTS` видим
какой из портов прокинут наружу.


---
Посмотреть запущенные контейнеры
---

Посмотреть только запущенные контейнеры можно командой

    docker ps 

---
Остановка запущенных контейнеров
---

Остановить запущенный контейнер можно командой

    docker stop <CONTAINER ID>
    docker stop 9c3786ba438c

---
Запустить контейнерна основе образа
---

Запустить контейнер на основе образа, можно по его `IMAGE ID`

    docker run <IMAGE ID> 

Пример запуска

    docker run 9c3786ba438c

Запустить контейнер на основе образа и войти в него с командой 
`bash`, есть зайти внутрь контейнера и запустить в нем терминал. 

    docker run <IMAGE ID> -it bash

---
Удалить контейнер
---

Удалить контейнер

    docker rm <CONTAINER ID>

---
Другие команды
---

Удалить все, совсем все ! вобще все, удаляет все изображения и все 
контейнеры, только с начала контейнеры надо остановить.

     docker system prune -a

---
Файл `Dockerfile`
---

`Dockerfile` - специальный файл который описывает какое изображение,
требуется создать.

Для создания образа нашего проекта, располагаем `Dockerfile` в файле
в корне нашего приложения, и описываем в нем команды для создания
образа, на основе той программы в которой находится этот докер файл.

---
Команды докер файла
---
`FROM` - указываем родительский образ, он будет являться базовым,
для всего что будет на нем располагаться.

`python:3.8-buster` - один из базовых образов, он создает контейнер 
с установленным в него `OC Linux` а внутри этой `ОС` уже предустановлен 
`python` версии 3.8

```
# Полноценная версия python
FROM python:3.8-buster

# Сильно урезанная версия python
FROM python:3.8-alpine
```

Существует множество образов, они подтягиваются с `Docker hub`, если
мы будем устанавливать пакеты, то в зависимости от содержимого 
базового образа, можем получить ошибки, ибо образ `python:3.8-alpine`
может просто не содержать нужных библиотек, так что надо следить
за тем образом который устанавливаем.

---
`COPY` - копирует что-то из корня нашего приложения в котором 
находится `Dockerfile` по указанному пути внутрь нашего контейнера. 

К примеру, скопировать все что есть, это указание символа точки ` . `
копировать в директорию по пути `/usr/src/app` внутрь нашего
контейнера, таким образом все файлы нашего проекта, будут скопированы
в указанную директорию.

```dockerfile
COPY . /usr/src/app
```

---
`WORKDIR` - изменить рабочую директорию, указываем путь к 
директории, после чего для всех последующих команд данная директория
становится рабочей, и команды будут исполняться там.

```dockerfile
WORKDIR /usr/src/app
```

---
`RUN` - запускает некоторую команду, в терминале внутри созданного
изображения, эта команда выполняется сразу же, то что будет выполнено
этой командой станет часть образа.

К примеру, установка зависимостей, все пакеты будут установлены,
и далее эти сам образ будет уже с этими установленными пакетами.

```dockerfile
RUN pip install -r requirements/production.txt
```

---
`CMD` - установка некоторой команды, эта команда не будет 
выполнена сразу же, и все ее производные не будут частью образа, 
но когда на основе этого образа мы создадим контейнер, то по 
умолчанию именно эта команда будет сразу же выполнена внутри
созданного контейнера.

К примеру, применение миграций будет на этапе создания контейнера. 

```dockerfile
CMD python3 manage.py migrate
```

или

```dockerfile
CMD ["python3", "manage.py", "migrate"]
```

[//]: # (---)

[//]: # (`ENTRYPOINT` - это директива, выполняет туже самую работу, что и )

[//]: # (директива `CMD`, но `CMD` используется для запуска одной команды,)

[//]: # (а директива `ENTRYPOINT` так называемая точка входа, вызывает на )

[//]: # (исполнение целый файл с командами.)

[//]: # ()
[//]: # (`docker-entrypoint.sh` - специальный файл с командами для исполнения)

[//]: # (в момент запуска контейнера.)

[//]: # ()
[//]: # (Пример использования.)

[//]: # ()
[//]: # (К примеру `Dockefile` для запуска `Django` проекта.)

[//]: # (```dockerfile)

[//]: # (FROM python:3.8)

[//]: # (WORKDIR /usr/src/app)

[//]: # (COPY ./requirements.txt .)

[//]: # (RUN pip install -r requirements.txt)

[//]: # (COPY . .)

[//]: # (ENTRYPOINT ["./docker-entrypoint.sh"])

[//]: # (```)

[//]: # ()
[//]: # (Файл `docker-entrypoint.sh` для него, с запуском миграций.)

[//]: # (``` )

[//]: # (#!/bin/sh)

[//]: # (python3 manage.py makemigrations)

[//]: # (python3 manage.py migrate)

[//]: # (```)

---
`EXPOSE` - указывает порт который, требуется открыть в основную систему,
просто прокидываем порт, благодаря чему программа слушающая свой порт в
своем контейнере будет доступна в основной системе через прокинутый порт.

```dockerfile
EXPOSE 5000
```

---
`ENV` - Мы можем указывать с какими переменными окружения запускать контейнер,
тут можно как сразу указать переменные окружения, так и указать путь к файлу из 
которого будут взяты переменные окружения.

```dockerfile
ENV PYTHONUNBUFFERED 1
```

---
`ADD`

```dockerfile
ADD . /code/
```


---
`MAINTAINER`

---
`USER`

---
`VOLUME`


Просмотр статистики контейнеров`docker stats`
---

Запустив множество контейнеров, мы можем просматривать их статистику с помощью
команды `docker stats`

```python
CONTAINER ID   NAME            CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O         PIDS
37fa0bc344b2   container_1     69.71%    12.29GiB / 19.55GiB   62.89%    516MB / 409kB     4.37GB / 26.3MB   1
86ed66e9bce8   container_2     0.00%     590.1MiB / 19.55GiB   2.95%     3.45GB / 3.78MB   11.9GB / 0B       8
2a9d0402dddc   container_3     0.00%     1.166GiB / 19.55GiB   5.97%     2.31GB / 2.91MB   47.7GB / 0B       9
```

Просмотр логов
---
Посмотреть логи в Docker контейнере можно след командой, эта команда
выводит последние логи в журнале.

    sudo docker logs 4461b7ad7f75

---

Что бы иметь возможность просматривать логи в живом режиме, указываем
флаг `--follow`

    sudo docker logs 4461b7ad7f75 --follow

Можно просматривать логи с указанием сколько именно последних сообщений
следует вывести

    sudo docker logs 4461b7ad7f75 --follow --tail=50

---
Запуск `docker` контейнеров
---

[//]: # (https://docs.docker.com/engine/reference/commandline/run/)

Запуская контейнеры, мы можем прямо при запуске указывать какие именно пути
пробрасывать, можем указывать переменные окружения. 

Справка по запуску командам docker из терминала:

```
    docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

---
\`pwd\` - это переменная которая указывает на текущий рабочий каталог

---
`-d` - запускаем контейнер и отсоединяемся от него, запускаем контейнер
в фоновом режиме 

---
`-it` - попадаем внутрь контейнера, `docker run <image id> -it bash` запустит
контейнер на основе изображения войдет в него и запустит сессию `bash`

---
`-v` или `--volume` - монтирует каталог в контейнер, `<путь на хост машине>:<путь внутри контейнера>`
монтировать каталог можно 2 способами, через указание абсолютного пути на хост машине,
и указания абсолютного пути внутри контейнера, к примеру так:

    -v home/serg/workdir:/app/workdir

Второй способ это указание пути с использованием специальной переменной \`pwd\` 
которая автоматически указывает на текущую директорию.

    -v `pwd`/innerdir:/app/workdir/innerdir

---
`--rm` - автоматически удалить созданный контейнер при его выходе

---
`--env-file <путь к файлу .env>` - указывает путь к файлу `.env` который прокидывается
в контейнер, и его переменные окружения применяются в контейнере.

---
`--env` или `-e` - установить одну переменную среды

---
`--entrypoint /bin/bash` - 

---
`-с "<команда>"` - команды в виде строки с которыми будет запущен скрипт

---
Команда запуска контейнера, из терминала с проброской путей и команд
```
    docker run
    -it 
    --rm 
    --env-file .env 
    -v `pwd`/output:/app/output 
    -v `pwd`/task.json:/app/task.json 
    -v /home/serg/workdir:/app/workdir 
    container_name_or-tag
    --run=hello_world       // команда для запуска python скрипта
```

1) **docker run** - запустить докер контейнер
2) **-it** - 
3) **--rm** - 
4) **--env-file .env** - прокидываем `.env` файл в контейнер
5) **-v `pwd`<путь в хост машине>:<путь в контейнере>** - 
6) **-v <путь в хост машине>:<путь в контейнере>**
7) Указываем образ контейнера
8) Указываем команду с которой будет запущена программа на `python`
