Хранение секретных настроек
---

Настройки в `Django` хранятся в файле `settings.py`, то есть 
настройки в `Django` это файл самого `python`  есть настройки
могут быть не только перечнем переменных `ключ = значений` но 
и могут иметь довольно сложную структуру.

Существует несколько подходов для хранения настроек.

1 способ, расширять локальными настройками
---

Хранить настройки в файле `settings.py` и расширять его локальными
настройками `settings_local.py` таким образом при разработке локально 
боевые настройки проекта будут перекрыты локальными.

В то время как файл `settings.py` будет находиться в `VCS` и именно эти 
настройки будут использованы в `dev` окружении, файл `settings_local.py`
будет внесен в `.gitignore` и не будет коммититься.

---
2 Хранить настройки в переменных окружения
---

Файлы со специальным расширением `.env` предназначены для
хранения перечня переменных окружения, мы можем использовать это,
не отслеживая файл `.env` и хранить в нем переменные окружения,

Суть в том что переменные окружения не будут комититься в 
репу, так же помимо этого когда мы собираем проект в `Docker`
мы можем при сборке указывать переменные окружения, с которыми
будет запускаться контейнер.

Если бы мы оставляли настройки просто в файлах, то при сборке проекта
в `DockerFile` каждый раз когда бы нам требовалось изменить настройки
нам бы приходилось, с начала менять настройки в файлах, а потом все
пересобирать. 

Но в `DockerFile` есть возможность указать переменные окружения с 
которыми можно запустить контейнер, и по этому мы можем менять 
переменные окружения прямо в `DockerFile` а уже после эти переменные 
окружения с которыми был запущен контейнер будут считаны в настройках 
программы.

Таким образом:
- Файл `env` не будет под `VCS`
- Мы можем запускать `Docker` контейнер и передавать в него эти 
переменные окружения, и нам не потребуется пересобирать образ

Так же оставляем в проекте файл `.env.template` котором указываем названия 
переменных окружения, но без значения, что бы было видно какие настройки
должны быть использованы для работы.

---
Запуск конкретной программы с переменными окружения
---

Можно запускать конкретную программу с переменными окружения
установленными специально для этой программы, для этого
переменные окружения перечисляются перед запуском самой
программы.

    TEST_ENV=777 python3 file.py

---
Модуль `os` для получения переменных окружения
---

И так мы определились что лучше использовать переменные окружения для
хранения настроек для проекта.

Получить переменные окружения в `python` можно с помощью модуля `os`,
к переменным окружения можно обращаться как к словарю `os.environ`

Выведем все доступные переменные окружения 
```python
import os

env_result = ''
for env in os.environ:
    env_result += f'{env} = {os.environ[str(env)]}</br>'
```

---
Модуль `django-environ`
---
По сути можно работать с переменными окружения через модуль
`os.environ` но в `Django` есть специальный модуль `django-environ`
который делает работу проще.

В сущности это просто модуль который позволяет считывать переменные 
окружения, с которыми был запущен процесс, а далее просто делаем эти 
переменные окружения настройками для нашего проекта.

Установка

    pip3 install django-environ

Импорт 

    import environ

В файле настроек `settings.py` пропишем такой код:

```python
import environ
import os

# Создаем экземпляр для работы с переменными окружения
env = environ.Env()

# __file__ это параметр модуля, название самого файла
# os.path.abspath() - получим абсолютный путь к файлу
# os.path.dirname() - дважды поднимаясь на уровень выше
# попадаем в корень директории нашего проекта
BASE_DIR = os.path.dirname(
              os.path.dirname(
                  os.path.abspath(__file__)
              )
            )

# Помещаем файл .env с перечисленными переменными окружения в
# директорию venv c виртуальным окружением, который не комитится в
# репу. Считываем этот файл с настройками с помощью env.read_env()
# и таким образом получаем настройки дял проекта которые не 
# комитятся в репозиторий
path_to_env_file = os.path.join(BASE_DIR, 'venv' , '.env')
env.read_env(path_to_env_file)

# Далее через переменную env можем получать доступ к переменным
# окружения, и тем самым вносить их в наши константы для настройки
# проекта

DEBUG = env('DEBUG')
SECRET_KEY = env('SECRET_KEY')
DATABASES = {
    'default': env.db(),
    'extra': env.db_url(
        'SQLITE_URL',
        default='sqlite:////tmp/my-tmp-sqlite.db'
    )
}

CACHES = {
    'default': env.cache(),
    'redis': env.cache_url('REDIS_URL')
}
```

Таким файлом настроек, мы можем получать доступ к переменным 
окружения, которые лежат в директории с виртуальным окружением,
и которые не будут комититься в репозиторий.
