Что такое `JWT` токены
---
---

[Полезная статья о JWT](https://habr.com/ru/post/340146/)

[Полезная статья о JWT](https://struchkov.dev/blog/what-is-jwt/)

[Сервис для декодирования JWT токенов](https://jwt.io/#debugger-io)

JSON Web Token (JWT) - это стандарт того как создавать токены на 
основе формата JSON, в основном его используют для передачи данных для
аутентификации в клиент-серверном приложении.

JWT токен создается на стороне сервера после передаются клиенту и 
сохраняется в браузере как обычный токен, далее при каждом обращении 
на сервер, этот JWT токен обрабатывается серверной стороной, JWT 
в основном используется для аутентификации пользователей, так что в
JWT токене в зашифрованном виде будет находиться информация о пользователе.

То есть информация о самом пользователе находится прямо в JWT и получая этот
токен на серверной стороне, после его декодирования мы получаем информацию о 
самом пользователе, таким образом возникает вопрос о безопасности 
использования этого механизма и можно ли подделать этот JWT токен. 

---
Структура `JWT` токена в расшифрованном виде
---

Когда `JWT` хранится в виде токена на стороне браузера он зашифрован и 
выглядит примерно след. образом
    
    eyJ0eXAiOi...QAIpJqBVW_Nftm9FdHl3CHNK6DKOEaH_35wwietYQ

Дешифровав его можно увидеть структуру `JWT` токена, он состоит из 
2 частей, `HEAD` в котором указывается в мета информация, и в основном
это алгоритм шифрования, и основная `PAYLOAD` это то как выглядит 

**Пример `JWT` токена в расшифрованном виде** 

Часть `HEAD`
```json
{
  "alg": "RS256"
}
```

Часть `PAYLOAD`
```json
  "sid": "fe8smx36-62ea-45f3-8a48-ae1406aee4f2",
  "iss": "identify",
  "uid": 1,
  "email": "admin@mail.ru",
  "CHECK_SUM": "b5d10980-dd28-4ab1-bf56-87ee4cf4a387",
  "ROLES": [
    "USER",
    "ADMIN"
  ],
  "IS_BLOCK": false,
  "aud": [
    "identify",
    "core"
  ],
  "exp": 1639724526,
  "iat": 1639724126
}
```

`exp` – дата истечения срока действия;

`iat` – время создания токена.

---
Подписанный и неподписанный `JWT` токен
---

`JWT` токен бывает подписанным и не подписанным, если токен подписан то 
у него указывается алгоритм шифрования.

```json
{
  "alg": "RS256"
}
```

Если токен не подписан то указываетс япросто `None`

```json
{
  "alg": "none"
}
```

---
Структура `JWT` токена в шифрованном виде
---
`JWT` в сериализованной форме – это строка состоящая из 3 частей:

    Header . Payload . Signature 

`Signature` - единственная часть что может отсутствовать, если JWT не 
подписан, то есть у его алгоритме шифрования указано `"alg": "none"`
то эта третья часть будет отсутствовать, именно указанный алгоритм
указывает как сформировать подпись для `JWT`


---
Правильное понимание того что такое `JWT` токен 
---

[ Почитать про JWT ](https://vc.ru/dev/106534-jwt-kak-bezopasnyy-sposob-autentifikacii-i-peredachi-dannyh)

`Access token` - токен переданный из сервера в браузер и в дальнейшем 
используется для аутентификации пользователя.

Поле `exp` обязательное, по нему определяем время окончания действия токена. 

Части токена `HEAD` и `PAYLOAD` кодированы в `Base64`

Первая и вторая части `HEAD` и `PAYLOAD` легко декодировать из `Base64`, 
по сути эти данные передаются в открытом виде.

**Третья часть `SIG`**

И так, у нас есть 2 части заголовок и сами данные, они кодированы в 
`Base64` и представляют собой 2 таких строчки.

>`HEAD` = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
> 
>`PAYLOAD` = eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9

Их можно легко расшифровать и изменить в них данные пользователя, алгоритм
шифрования применяемый для них, не так важен, цель токена не зашифровать эти 
данные пользователя так, чтобы их нельзя было расшифровать, а в том, чтобы
подтвердить, изменялись эти данные или не изменялись.

Именно для подтверждения были изменены эти данные или нет, и используется 
третья часть `SIG`.

На сервере, где происходит формирование `JWT` токена, есть все необходимые
данные `HEAD`, `PAYLOAD` эти кодированные данные объединяются через точку
таким образом получаем единую строчку.

> `DATA` = `HEAD` . `PAYLOAD`

Далее на Сервере генерируется уникальный ключ, назовем его `SECRET` далее 
берется используемый алгоритм шифрования, который указан в `HEAD` и с его
помощью, с `DATA` в виде данных и `SECRET` в виде соли для шифрования, 
генерируется новый секретный ключ `SIG`.

> `DATA` = `HEAD` . `PAYLOAD`
> 
> `SIG` =  `SHA256(DATA, SECRET)` 
 
Далее сервер имеет на руках секретный ключ `SECRET` который известен только
серверу и больше никому, и имеет `SIG` которая представляет из себя результат 
шифрования и называется открытым ключом.

После из уже известный легко кодированных данных `DATA` и открытого ключа `SIG`
и формируется полный токен, состоящий из 3 частей.

> `HEAD` . `PAYLOAD` .  `SIG`

В результате этого у нас и появляется то что называется `Access token` токен 
состоящий из 3 склеенных частей.

---
Проверка `JWT` токена
---
И так был сгенерирован `JWT` токен состоящий из 3 частей, сервер запоминает 
секретный ключ `SECRET` а `JWT` токен отдает клиенту, клиент в свою очередь 
принимает токен и сохраняет его, далее при каждом обращении клиента к серверу,
клиент передает серверу этот `JWT` токен в заголовке.

Когда сервер принимает этот `JWT` с начала он должен убедиться что данные из 
частей `HEAD` и `PAYLOAD` небыли изменены, и в случае удачной проверки, можно 
просто брать информацию о пользователе прямо из части `PAYLOAD` и по этим 
аутентифицировать пользователя.

**Этап проверки**

Проделываем туже самую операцию, берем `HEAD` и `PAYLOAD` пришедшие из токена,
далее берем сохраненный секретный ключ `SECRET`, и кодируем в тем же алгоритмом
которым кодировали и в прошлый раз, в результате этого генерируется новая 
сигнатура `SIG-2` 

Каждая из сигнатур сгенерирован из одних и тех же данных, с одним и тем же
секретным ключом, если эти сигнатуры совпадают, значит данные не меняли, если
они не совпадают, значит что-то из данных все таки было изменено, а раз изменено
значит таким данным доверять нельзя.

---
Что такое DRF-SSO и при чем тут JWT
---

[Репозиторий django-rest-framework-sso](https://github.com/namespace-ee/django-rest-framework-sso)

`DRF-SSO` - Это расширение Django REST Framework, которое обеспечивает
единый вход в среде, ориентированной на микросервисы, с использованием
стандарта JWT.
