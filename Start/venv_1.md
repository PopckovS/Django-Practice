Переменные окружения в Linux
---
---

Переменные окружения в Linux - это специальные переменные 
используемые программами во время выполнения, они определяются 
как системой, так и пользователем.

Пользовательские переменные окружения устанавливаются 
пользователем, для текущей оболочки, временно или постоянно.

Окружение реализовано как строка, состоящая из пары 
ключ-значение, если определяется несколько значений, то они
последовательно разделены знаком двоеточия. 

    KEY=value1:value2:...

Если значение должно иметь пробелы, то используем кавычки

    KEY="value with spaces"

---

Таким образом мы можем создавать переменные, они могут быть
2 типов:

> 1) Переменные Окружения - переменные, определенные для текущей 
> оболочки, и они наследуются для всех дочерних процессов и всех
> запущенных процессов.
> 
> 
> 2) Переменные Оболочки - это переменные, которые содержатся 
> исключительно в оболочке, где они были определены или 
> установлены.

Эти переменные принято называть с заглавных букв.

---

Список всех переменных окружения можно распечатать командами:

    # Выводит все переменные окружения
    printenv

    # Или выводит указанную переменную окружения
    printenv HOME

    /home/serg

Или командой

    # Выводит все переменные окружения 
    env

В результате получи список всех переменных окружения:

    ...
    PWD=/home/serg
    HOME=/home/serg
    ...

---
Полезные переменные окружения
---
В переменных окружения есть ряд значимых переменных, такие как:

`SHELL` - путь к оболочке что интерпретирует команды /bin/bash

`USER` - текущий пользователь оболочки

`PWD` - текущая директория

`OLDPWD` - преведущая директория

`PATH` - список директорий в которых оболочка будет искать 
команды на выполнение, система проверяет эти директории в
указанном порядке, находит файл со скриптом, что соответствует 
команде и запускает его на выполнение.

`LANG` - текущий язык с кодировкой en_US.UTF-8

`HOME` - домашняя директория текущего пользователя

---

Вывести переменные оболочки можно командой 

    set

---
Создание переменной оболочки
---

Создать переменную оболочки можно простой командой 

     TEST_VAR='Hello World!'

Посмотреть ее можно при помощи выборки, специальная 
команда `| grep` позволяет выбрать нужный результат из массы.

    # Задаем переменную оболочки
    TEST_VAR='Hello World!'

    # Получить из всего вывода set только переменную 
    # с названием TEST_VAR 
    set | grep TEST_VAR

    # идим результат вывода
    TEST_VAR='Hello World!'

Таким образом определенная переменная будет доступна в
текущей сессии терминала, но в дочернем процессе она будет
отсутствовать.

Используем команду `bash` чтобы запустить дочернюю сессию

    # Создаем новую сессию
    bash 

    # Видим что переменной оболочки установленной ранее, нету
    set | grep TEST_VAR

**Таким образом, переменные оболочки существуют только в 
контексте текущей сессии, и не видны в дочерних процессах**

Если нам требуется просто вывести значение переменной, то
можно использовать команду `echo`

    echo $TEST_VAR
    Hello World!

---
Создание переменной окружения
---
Чтобы создать переменную окружения, мы можем командой `export`

    export TEST_VAR
    printenv | grep TEST_VAR
    TEST_VAR=Hello World!
    bash
    echo $TEST_VAR
    Hello World!

**Главное отличие переменной окружения от переменной оболочки,
в том что переменная окружения наследуется в дочерние 
процессы.**

---
Удаление переменной окружения 
---

Сделать это можно такой командой

    export -n TEST_VAR

Или

    unset TEST_VAR

---
Файл `bashrc` с переменными окружения
---

В не зависимости какие переменные окружения или оболочки мы
устанавливаем, все они доступны только в текущей сессии.

И при открытии новой сессии их значения будут обнулены, для
того что бы установить эти значения по умолчанию, что бы они 
были доступны всегда, в каждой сессии.

В домашней директории пользователя, есть файл `bashrc`
с предопределенными переменными окружения.

Добавим в его конец строку

    export VARNAME=value

Теперь эта переменная будет автоматически являться переменной
окружения, при запуске каждой новой сессии.

Для того ято бы изменения вступили в силу сразу же, а не 
после перезапуска, исполним команду

    source ~/.bashrc

Этим указываем использовать в качестве ресурса дял сессии,
файл `bashrc` что находится в домашней директории 
текущего пользователя.

---
Хранение секретных настроек
---

Настройки в `Django` хранятся в файле `settings.py`, то есть 
настройки в `Django` это файл самого `python`  есть настройки
могут быть не только перечнем переменных `ключ = значений` но 
и могут иметь довольно сложную структуру.

Существует несколько подходов для хранения настроек.

1 способ, расширять локальными настройками
---

Хранить настройки в файле `settings.py` и расширять его локальными
настройками `settings_local.py` таким образом при разработке локально 
боевые настройки проекта будут перекрыты локальными.

В то время как файл `settings.py` будет находиться в `VCS` и именно эти 
настройки будут использованы в `dev` окружении, файл `settings_local.py`
будет внесен в `.gitignore` и не будет коммититься.

---
2 Хранить настройки в переменных окружения
---

Файлы со специальным расширением `.env` предназначены для
хранения перечня переменных окружения, мы можем использовать это,
не отслеживая файл `.env` и хранить в нем переменные окружения,

Суть в том что переменные окружения не будут комититься в 
репу, так же помимо этого когда мы собираем проект в `Docker`
мы можем при сборке указывать переменные окружения, с которыми
будет запускаться контейнер.

Если бы мы оставляли настройки просто в файлах, то при сборке проекта
в `DockerFile` каждый раз когда бы нам требовалось изменить настройки
нам бы приходилось, с начала менять настройки в файлах, а потом все
пересобирать. 

Но в `DockerFile` есть возможность указать переменные окружения с 
которыми можно запустить контейнер, и по этому мы можем менять 
переменные окружения прямо в `DockerFile` а уже после эти переменные 
окружения с которыми был запущен контейнер будут считаны в настройках 
программы.

Таким образом:
- Файл `env` не будет под `VCS`
- Мы можем запускать `Docker` контейнер и передавать в него эти 
переменные окружения, и нам не потребуется пересобирать образ

Так же оставляем в проекте файл `.env.template` котором указываем названия 
переменных окружения, но без значения, что бы было видно какие настройки
должны быть использованы для работы.

---
Запуск конкретной программы с переменными окружения
---

Можно запускать конкретную программу с переменными окружения
установленными специально для этой программы, для этого
переменные окружения перечисляются перед запуском самой
программы.

    TEST_ENV=777 python3 file.py

---
Модуль `os` для получения переменных окружения
---

И так мы определились что лучше использовать переменные окружения для
хранения настроек для проекта.

Получить переменные окружения в `python` можно с помощью модуля `os`,
к переменным окружения можно обращаться как к словарю `os.environ`

Выведем все доступные переменные окружения 
```python
import os

env_result = ''
for env in os.environ:
    env_result += f'{env} = {os.environ[str(env)]}</br>'
```

---
Модуль `django-environ`
---
По сути можно работать с переменными окружения через модуль
`os.environ` но в `Django` есть специальный модуль `django-environ`
который делает работу проще.

В сущности это просто модуль который позволяет считывать переменные 
окружения, с которыми был запущен процесс, а далее просто делаем эти 
переменные окружения настройками для нашего проекта.

Установка

    pip3 install django-environ

Импорт 

    import environ

В файле настроек `settings.py` пропишем такой код:

```python
import environ
import os

# Создаем экземпляр для работы с переменными окружения
env = environ.Env()

# __file__ это параметр модуля, название самого файла
# os.path.abspath() - получим абсолютный путь к файлу
# os.path.dirname() - дважды поднимаясь на уровень выше
# попадаем в корень директории нашего проекта
BASE_DIR = os.path.dirname(
              os.path.dirname(
                  os.path.abspath(__file__)
              )
            )

# Помещаем файл .env с перечисленными переменными окружения в
# директорию venv c виртуальным окружением, который не комитится в
# репу. Считываем этот файл с настройками с помощью env.read_env()
# и таким образом получаем настройки дял проекта которые не 
# комитятся в репозиторий
path_to_env_file = os.path.join(BASE_DIR, 'venv' , '.env')
env.read_env(path_to_env_file)

# Далее через переменную env можем получать доступ к переменным
# окружения, и тем самым вносить их в наши константы для настройки
# проекта

DEBUG = env('DEBUG')
SECRET_KEY = env('SECRET_KEY')
DATABASES = {
    'default': env.db(),
    'extra': env.db_url(
        'SQLITE_URL',
        default='sqlite:////tmp/my-tmp-sqlite.db'
    )
}

CACHES = {
    'default': env.cache(),
    'redis': env.cache_url('REDIS_URL')
}
```

Таким файлом настроек, мы можем получать доступ к переменным 
окружения, которые лежат в директории с виртуальным окружением,
и которые не будут комититься в репозиторий.

---

В зависимости от типа настроек мы используем разные методы получения 
этих настроек, также можно задавать дефолтные значения если такое переменной 
окружения не найдено, по сути работает так же как и метод `get` словарей. 

```python
env.bool('DEBUG', default=False)
```

```python
env.str('MEDIA_URL', default='media/')
```

